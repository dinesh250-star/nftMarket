{"ast":null,"code":"var _regeneratorRuntime = require(\"C:/a/nft-marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _awaitAsyncGenerator = require(\"C:/a/nft-marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"C:/a/nft-marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"C:/a/nft-marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar BufferList = require('bl/BufferList');\n\nmodule.exports = function (source) {\n  var reader = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var bytes, bl, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, data;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return;\n\n          case 2:\n            bytes = _context.sent;\n            // Allows us to receive 8 when reader.next(8) is called\n            bl = new BufferList();\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 6;\n            _iterator = _asyncIterator(source);\n\n          case 8:\n            _context.next = 10;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 10:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 37;\n              break;\n            }\n\n            chunk = _step.value;\n\n            if (bytes) {\n              _context.next = 18;\n              break;\n            }\n\n            _context.next = 15;\n            return bl.append(chunk);\n\n          case 15:\n            bytes = _context.sent;\n            bl = new BufferList();\n            return _context.abrupt(\"continue\", 34);\n\n          case 18:\n            bl.append(chunk);\n\n          case 19:\n            if (!(bl.length >= bytes)) {\n              _context.next = 34;\n              break;\n            }\n\n            data = bl.shallowSlice(0, bytes);\n            bl.consume(bytes);\n            _context.next = 24;\n            return data;\n\n          case 24:\n            bytes = _context.sent;\n\n            if (bytes) {\n              _context.next = 32;\n              break;\n            }\n\n            if (!bl.length) {\n              _context.next = 31;\n              break;\n            }\n\n            _context.next = 29;\n            return bl;\n\n          case 29:\n            bytes = _context.sent;\n            bl = new BufferList();\n\n          case 31:\n            return _context.abrupt(\"break\", 34);\n\n          case 32:\n            _context.next = 19;\n            break;\n\n          case 34:\n            _iteratorAbruptCompletion = false;\n            _context.next = 8;\n            break;\n\n          case 37:\n            _context.next = 43;\n            break;\n\n          case 39:\n            _context.prev = 39;\n            _context.t0 = _context[\"catch\"](6);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 43:\n            _context.prev = 43;\n            _context.prev = 44;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 48;\n              break;\n            }\n\n            _context.next = 48;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 48:\n            _context.prev = 48;\n\n            if (!_didIteratorError) {\n              _context.next = 51;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 51:\n            return _context.finish(48);\n\n          case 52:\n            return _context.finish(43);\n\n          case 53:\n            if (!bytes) {\n              _context.next = 55;\n              break;\n            }\n\n            throw Object.assign(new Error(\"stream ended before \".concat(bytes, \" bytes became available\")), {\n              code: 'ERR_UNDER_READ',\n              buffer: bl\n            });\n\n          case 55:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[6, 39, 43, 53], [44,, 48, 52]]);\n  }))();\n\n  reader.next();\n  return reader;\n};","map":{"version":3,"sources":["C:/a/nft-marketplace/node_modules/it-reader/index.js"],"names":["BufferList","require","module","exports","source","reader","bytes","bl","chunk","append","length","data","shallowSlice","consume","Object","assign","Error","code","buffer","next"],"mappings":";;;;;;;;AAAA,IAAMA,UAAU,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AAEAC,MAAM,CAACC,OAAP,GAAiB,UAAAC,MAAM,EAAI;AACzB,MAAMC,MAAM,GAAG,2DAAC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACF;;AADE;AACVC,YAAAA,KADU;AACI;AACdC,YAAAA,EAFU,GAEL,IAAIP,UAAJ,EAFK;AAAA;AAAA;AAAA;AAAA,uCAIYI,MAJZ;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIGI,YAAAA,KAJH;;AAAA,gBAKPF,KALO;AAAA;AAAA;AAAA;;AAAA;AAMF,mBAAMC,EAAE,CAACE,MAAH,CAAUD,KAAV,CAAN;;AANE;AAMVF,YAAAA,KANU;AAOVC,YAAAA,EAAE,GAAG,IAAIP,UAAJ,EAAL;AAPU;;AAAA;AAWZO,YAAAA,EAAE,CAACE,MAAH,CAAUD,KAAV;;AAXY;AAAA,kBAaLD,EAAE,CAACG,MAAH,IAAaJ,KAbR;AAAA;AAAA;AAAA;;AAcJK,YAAAA,IAdI,GAcGJ,EAAE,CAACK,YAAH,CAAgB,CAAhB,EAAmBN,KAAnB,CAdH;AAeVC,YAAAA,EAAE,CAACM,OAAH,CAAWP,KAAX;AAfU;AAgBF,mBAAMK,IAAN;;AAhBE;AAgBVL,YAAAA,KAhBU;;AAAA,gBAmBLA,KAnBK;AAAA;AAAA;AAAA;;AAAA,iBAoBJC,EAAE,CAACG,MApBC;AAAA;AAAA;AAAA;;AAAA;AAqBE,mBAAMH,EAAN;;AArBF;AAqBND,YAAAA,KArBM;AAsBNC,YAAAA,EAAE,GAAG,IAAIP,UAAJ,EAAL;;AAtBM;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,iBA+BVM,KA/BU;AAAA;AAAA;AAAA;;AAAA,kBAgCNQ,MAAM,CAACC,MAAP,CACJ,IAAIC,KAAJ,+BAAiCV,KAAjC,6BADI,EAEJ;AAAEW,cAAAA,IAAI,EAAE,gBAAR;AAA0BC,cAAAA,MAAM,EAAEX;AAAlC,aAFI,CAhCM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAD,IAAf;;AAuCAF,EAAAA,MAAM,CAACc,IAAP;AACA,SAAOd,MAAP;AACD,CA1CD","sourcesContent":["const BufferList = require('bl/BufferList')\n\nmodule.exports = source => {\n  const reader = (async function * () {\n    let bytes = yield // Allows us to receive 8 when reader.next(8) is called\n    let bl = new BufferList()\n\n    for await (const chunk of source) {\n      if (!bytes) {\n        bytes = yield bl.append(chunk)\n        bl = new BufferList()\n        continue\n      }\n\n      bl.append(chunk)\n\n      while (bl.length >= bytes) {\n        const data = bl.shallowSlice(0, bytes)\n        bl.consume(bytes)\n        bytes = yield data\n\n        // If we no longer want a specific byte length, we yield the rest now\n        if (!bytes) {\n          if (bl.length) {\n            bytes = yield bl\n            bl = new BufferList()\n          }\n          break // bytes is null and/or no more buffer to yield\n        }\n      }\n    }\n\n    // Consumer wants more bytes but the source has ended and our buffer\n    // is not big enough to satisfy.\n    if (bytes) {\n      throw Object.assign(\n        new Error(`stream ended before ${bytes} bytes became available`),\n        { code: 'ERR_UNDER_READ', buffer: bl }\n      )\n    }\n  })()\n\n  reader.next()\n  return reader\n}\n"]},"metadata":{},"sourceType":"script"}